#include "deploy.h"

int 	serviceTableNum=0;
int 	serviceTable[500];
bool	isAdded[500];

void dfsForTraversal(int deepCount)//深度优先搜索,完成不同组合
{
	if(deepCount>=consumNodeNum)	return;
  //printf("deepCount:%d\n",deepCount);
	for(int i=0;i<conNode[deepCount].feasibleServiceNodeNum;i++)
	{
		if(serviceTableNum>0)//检查是否重复
		{
			for(int j=0;j<serviceTableNum;j++)
			{
				if(serviceTable[j]==conNode[deepCount].feasibleServiceNode[i])
				{
					isAdded[deepCount]=false;
					goto loop;
				}
			}
		}
		isAdded[deepCount]=true;
		serviceTable[serviceTableNum]=conNode[deepCount].feasibleServiceNode[i];
		serviceTableNum++;
		loop:	;

		if(deepCount==consumNodeNum-1)
		{
      //for(int j=0;j<serviceTableNum;j++)  printf("%d ",serviceTable[j]);
      //printf("\n");

			copeWith(serviceTableNum);
      //printf("Done!\n");
		}
		else
		{
			dfsForTraversal(deepCount+1);
		}
		if(isAdded[deepCount])	serviceTableNum--;
	}
}

void copeWith(int serviceNum)//根据组合的处理函数
{
	int tmpFlow;
	minCost=serviceNum*serverPrice;
	for(int j=0;j<nodeNum;j++)//重新初始化带宽capacity
	{
		for(int k=0;k<node[j].linkedNum;k++)
			node[j].capacity[k]=node[j].state[k];
	}

	freeSuperSource();
	insertSuperSource(serviceTable,serviceNum);
	tmpFlow=minCostMaxFlow(nodeNum+1,nodeNum);

  //printf("MaxFlow:%d\n",MaxFlow);
  //printf("tmpFlow:%d\n",tmpFlow);

	if(tmpFlow==MaxFlow)
	{
		if(minCost<miniCostUntilNow)
		{
			miniCostUntilNow=minCost;//更新最优费用
			printf("%ld\n",miniCostUntilNow);
	
			//更新最优路径
			for(int k=0;k<bestPathNum;k++)//清空原来的
			{
				while(!bestPath[k].empty())	bestPath[k].pop();
			}
			for(int k=0,v;k<FeasiblePathNum;k++)//
			{
				v=0;
				while(FeasiblePath[k][v] != -1)
				{
					bestPath[k].push(FeasiblePath[k][v]);
					v++;
				}
			}
			bestPathNum=FeasiblePathNum;
		}
	}
}
/*********************************************************************
**********插入函数:将给定的数组,做为超级源点输出的第一级**************
*********************************************************************/
void insertSuperSource(int* a,int len)
{
	for(int i=0;i<len;i++)
	{
		node[nodeNum+1].linkedNode[node[nodeNum+1].linkedNum]=a[i];
		node[nodeNum+1].capacity[node[nodeNum+1].linkedNum]=INF;
		node[nodeNum+1].state[node[nodeNum+1].linkedNum]=INF;
		node[nodeNum+1].cost[node[nodeNum+1].linkedNum]=0;
		node[nodeNum+1].linkedNum++;
	}
}
/*********************************************************************
**************删除函数:将超级源点的输出全部删除*************************
*********************************************************************/
void freeSuperSource()
{
	node[nodeNum+1].linkedNum=0;
}
/*********************************************************************
**********插入函数:将给定的数组,做为超级汇点输出的第一级**************
*********************************************************************/
void insertSuperT()
{
	for(int i=0;i<consumNodeNum;i++)
	{
		node[conNode[i].linkNode].linkedNode[node[conNode[i].linkNode].linkedNum]=nodeNum;
		node[conNode[i].linkNode].capacity[node[conNode[i].linkNode].linkedNum]=conNode[i].demand;
		node[conNode[i].linkNode].state[node[conNode[i].linkNode].linkedNum]=conNode[i].demand;
		node[conNode[i].linkNode].cost[node[conNode[i].linkNode].linkedNum]=0;
		node[conNode[i].linkNode].linkedNum++;
	}
}



