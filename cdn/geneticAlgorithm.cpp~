/**************************************************************
/说明：意图将每个消费节点的服务器节点作为一个基因，
/			多个形成基因链。然后，进行遗传算法的迭代
**************************************************************/
#include "deploy.h"

#define groupNum 6					//定义种群大小
#define NG 1000							//种群的最大繁殖代数

GeneChain geneChain[groupNum];	//定义种群
/*********************************************************************
********遗传算法主程序:geneLength:基因链长度，引用消费节点数**********
*********************************************************************/
void geneticAlgorithm(int& geneLength)
{
	srand(time(NULL)); 				//定义随机数生成的种子
	int 		generation=0; 		//当前繁殖的最大代数
	float  	pc=0.90; 					//定义交叉的概率
	float  	pm=0.45; 					//定义变异的概率
	float		pro;

	initFirstGeneration(geneLength);			//初代的初始化

	//当停止准则不满足 即繁殖代数没到最大代数 ,继续繁殖
	while(generation<=NG)
	{
		for(int i=0;i<groupNum;i++)
		{
			for(int j=0;j<geneLength;j++)
				{geneChain[i].gene[j]=geneChain[i].childGene[j];cout<<geneChain[i].gene[j]<<" ";}
			cout<<endl;
		}

		fitnessFunction();
		//cout<<"Done!"<<endl;
		//选择双亲
		for(int i=0;i<groupNum;i++)//8选6?;随机,看落点
		{
			if(i==0)		//保留最优		实现位置待定
				for(int j=0;j<geneLength;j++)	geneChain[0].childGene[j]=geneChain[0].gene[j];
			else
			{
				pro=(float)rand()/(RAND_MAX+1.0);
				if(pro<geneChain[0].rate)
					for(int j=0;j<geneLength;j++)	geneChain[i].childGene[j]=geneChain[0].gene[j];
				else if(pro>=geneChain[0].rate&&pro<geneChain[1].rate)
					for(int j=0;j<geneLength;j++)	geneChain[i].childGene[j]=geneChain[1].gene[j];
				else if(pro>=geneChain[1].rate&&pro<geneChain[2].rate)
					for(int j=0;j<geneLength;j++)	geneChain[i].childGene[j]=geneChain[2].gene[j];
				else if(pro>=geneChain[2].rate&&pro<geneChain[3].rate)
					for(int j=0;j<geneLength;j++)	geneChain[i].childGene[j]=geneChain[3].gene[j];
				else if(pro>=geneChain[4].rate&&pro<geneChain[5].rate)
					for(int j=0;j<geneLength;j++)	geneChain[i].childGene[j]=geneChain[4].gene[j];
				else
					for(int j=0;j<geneLength;j++)	geneChain[i].childGene[j]=geneChain[5].gene[j];
			}
		}
		//***************************杂交算子***************************
		int r=0;
		int z=0;
		for(int j=0;j<groupNum;j++)
		{
			pro=rand()/(RAND_MAX+1.0);
			if(pro<pc)
			{
				++z;
				if(z%2==0)	Xover(geneChain[r],geneChain[j],geneLength);
				else				r=j;
			}
		}
		//***************************变异算子***************************
		//int pos;
		for(int i=0;i<=groupNum;i++) 
		{
			for(int j=0;j<geneLength;j++)
			{
				pro=rand()/(RAND_MAX+1.0);//在[0,1]区间产生随机数
				if(pro<pm)
				{	//在基因链的j位进行变异
					geneChain[i].childGene[j]=conNode[j].feasibleServiceNode[(int)\
						((float)conNode[j].feasibleServiceNodeNum*rand()/(RAND_MAX+1.0))];
				}
			}
		}

		generation++;
		cout<<"generation:"<<generation<<endl; //种群繁殖一代
	}
}
/*********************************************************************
***********基因杂交函数:根据选定的双亲，完成基因的交叉操作************
*********************************************************************/
void Xover(GeneChain& a,GeneChain& b,int& geneLength)
{ 
	int pos; 				//随机生成杂交点 即第几个分量进行相互交换
	int tmp;				//用于交换的暂存变量
	pos=(int)(geneLength*rand()/(RAND_MAX+1.0)); //在n个分量中，随机确定第pos个分量
	for(int i=0;i<pos;i++)
	{
		tmp=a.childGene[i];
		a.childGene[i]=b.childGene[i];
		b.childGene[i]=tmp;
	}
}
/*********************************************************************
******初始种群初始化函数:length:基因链长度;保证每个基因链都可行*******
*********************************************************************/
void initFirstGeneration(int& length)	//初代种群初始化,
{
	for(int i=0;i<groupNum;i++)
	{
		if(0==i)
			for(int j=0;j<length;j++)	geneChain[0].childGene[j]=conNode[j].linkNode;
		else
		{
			for(int j=0;j<length;j++)
			{
				geneChain[i].childGene[j]=conNode[j].feasibleServiceNode[(int)\
					((float)conNode[j].feasibleServiceNodeNum*rand()/(RAND_MAX+1.0))];
			}
		}

/*	do
		{
			//cout<<"Done!"<<endl;
			for(int j=0;j<length;j++)
			{
				geneChain[i].childGene[j]=conNode[j].feasibleServiceNode[(int)\
					((float)conNode[j].feasibleServiceNodeNum*rand()/(RAND_MAX+1.0))];
			}

			serviceTableNum=0;
			for(int j=0,k;j<consumNodeNum;j++)
			{
				if(j!=0)
				{
					k=0;
					while(k<serviceTableNum)
					{
						if(serviceTable[k]==geneChain[i].childGene[j])	goto	iignore;
						k++;
					}
				}
				serviceTable[serviceTableNum]=geneChain[i].childGene[j];
				serviceTableNum++;
				iignore:	;
			}
			//cout<<"serviceTable:";
			//for(int j=0;j<serviceTableNum;j++)cout<<serviceTable[j]<<" ";
			//cout<<endl;
			//最小费用最大流处理
			minCost=serviceTableNum*serverPrice;//操作之前应完成服务器节点的更新
			for(int j=0;j<nodeNum;j++)//重新初始化带宽capacity
			{
				for(int k=0;k<node[j].linkedNum;k++)
					node[j].capacity[k]=node[j].state[k];
			}

			freeSuperSource();
			insertSuperSource(serviceTable,serviceTableNum);
		}while(MaxFlow!=minCostMaxFlow(nodeNum+1,nodeNum));	//确保初始种群都可行
*/

	}
}
/*********************************************************************
*********适合度计算函数:包含每个基因链 费用的计算;********************
************************更优值的比较保存,并计算适合度*****************
*********************************************************************/
void fitnessFunction()//定义适合度函数
{
	long		tmpFlow;
	double	sum;
	long		tmpCost=2*miniCostUntilNow;

	for(int i=1;i<groupNum;i++)	//对后8个基因链依次处理
	{
		//**************根据每个个体基因链初始化服务器列表**************
		serviceTableNum=0;
		for(int j=0,k;j<consumNodeNum;j++)
		{
			if(j!=0)
			{
				k=0;
				while(k<serviceTableNum)
				{
					if(serviceTable[k]==geneChain[i].gene[j])	goto	ignore;
					k++;
				}
			}
			serviceTable[serviceTableNum]=geneChain[i].gene[j];
			serviceTableNum++;
			ignore:	;
		}
		
		//**********************最小费用最大流处理**********************
		minCost=serviceTableNum*serverPrice;//操作之前应完成服务器节点的更新
		for(int j=0;j<nodeNum;j++)//重新初始化带宽capacity
		{
			for(int k=0;k<node[j].linkedNum;k++)
				node[j].capacity[k]=node[j].state[k];
		}

		freeSuperSource();
		insertSuperSource(serviceTable,serviceTableNum);
		tmpFlow=minCostMaxFlow(nodeNum+1,nodeNum);
		//****************************检查更新*************************
		if(MaxFlow==tmpFlow)
		{
			if(minCost<miniCostUntilNow)
			{
				miniCostUntilNow=minCost;//更新最优费用
				cout<<"miniCostUntilNow:"<<miniCostUntilNow<<endl;

				//更新最优路径
				for(int k=0;k<bestPathNum;k++)//清空原来的
					while(!bestPath[k].empty())	bestPath[k].pop();

				for(int k=0,v;k<FeasiblePathNum;k++)//更新
				{
					v=0;
					while(FeasiblePath[k][v] != -1)
						{bestPath[k].push(FeasiblePath[k][v]);v++;}
				}
				bestPathNum=FeasiblePathNum;

				//更新最优基因链
				swapArray(geneChain[0],geneChain[i],consumNodeNum);
				swap(geneChain[0].cost,geneChain[i].cost);
			}
			geneChain[i].cost=minCost;//minCost全局变量,记录最小费用流的费用
		}
		else
		{
			geneChain[i].cost=miniCostUntilNow;			//不满足最大流
		}
	}
	//************************计算适应度*****************************

	sum=0.0;
	//因为总费用越小越优，这里做了下处理
	for(int i=0;i<groupNum;i++)	sum+=tmpCost-geneChain[i].cost;
	for(int i=0;i<groupNum;i++)
	{
		if(0==i)
			geneChain[i].rate=geneChain[i].cost/sum;
		else
			geneChain[i].rate=geneChain[i].cost/sum+geneChain[i-1].rate;
	}
}
/*********************************************************************
*****数组元素交换函数函数:length:基因链长度;主要完成最优基因链的交换*****
*********************************************************************/
void swapArray(GeneChain& a,GeneChain& b,int length)
{
	int tmp;
	for(int i=0;i<length;i++)
	{
		tmp=a.gene[i];
		a.gene[i]=b.gene[i];
		b.gene[i]=tmp;
	}
}


