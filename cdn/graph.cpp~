#include "deploy.h"

bool  ifClogged[1000];					//用于dfs函数中剪枝
bool 	ifInTheTable[500][1000];	//用于标记是否能够到达 普通节点
int   commonFlag[1000];					//用于记录 可能公共节点 被几个消费节点共有
int   countNum=0;								//用于dfs 搜索深度的计数
int		tmpCost=0;								//暂时记费用

/*********************************************************************
***********图的数据读取函数:包括节点及消费节点结构体的初始化**********
*********************************************************************/
void dataCatch(char* graph[MAX_EDGE_NUM],int edge_num)
{
	//*************************相关数组的初始化**********************
	sscanf(graph[0],"%d %d %d",&nodeNum,&linkNum,&consumNodeNum);//第一行
	//printf("%d %d %d\n",nodeNum,linkNum,consumNodeNum);
	//printf("\n");
	//************************服务器单位费用************************
	sscanf(graph[2],"%d",&serverPrice);											//第三行
	//************************普通节点信息**************************
	int start,end,capacity,cost;
	for(int i=4;i<linkNum+4;i++)//存储节点、链路信息;链路包含在节点内
	{														//认为编号从0开始，且连续
		sscanf(graph[i],"%d %d %d %d",&start,&end,&capacity,&cost);
		node[start].linkedNode[node[start].linkedNum]=end;
		node[start].capacity[node[start].linkedNum]=capacity;
		node[start].state[node[start].linkedNum]=capacity;
		node[start].cost[node[start].linkedNum]=cost;
		node[start].linkedNum++;

		node[end].linkedNode[node[end].linkedNum]=start;
		node[end].capacity[node[end].linkedNum]=capacity;
		node[end].state[node[end].linkedNum]=capacity;
		node[end].cost[node[end].linkedNum]=cost;
		node[end].linkedNum++;
		//printf("%d %d %d\n",start,end,capacity);
	}
 //************************消费节点信息**************************
	for(int i=linkNum+5;i<edge_num;i++)
	{
		sscanf(graph[i],"%d %d %d",&start,&end,&capacity);
		conNode[start].linkNode=end;
		conNode[start].demand=capacity;
		//printf("%d %d %d %d\n",start,end,capacity,cost);
    //****************************************
		indexOfconNode[end]=start; //设置反向索引
		//****************************************
    MaxFlow+=capacity;         //设置总的消费流量，用做最大流的检测
		
	}
}
/*********************************************************************
*******排序函数:将每个节点中存储的 邻节点 按单位租用费用排序**********
*********************************************************************/
void sortBaedOnCost()
{
	int tmp;
	for(int i=0;i<nodeNum+2;i++)
	{
		for(int j=0;j<node[i].linkedNum;j++)
		{
			tmp=node[i].cost[j];
			for(int K=j+1;K<node[i].linkedNum;K++)
			{	//这里默认每个节点至少一个与之连接
				if(tmp < node[i].cost[K])	tmp=node[i].cost[K];
			}
			node[i].cost[j]=tmp;
		}
	}
}
/*********************************************************************
******公共节点搜索函数:搜索潜在服务器节点,并标记能到达的消费节点******
*********************************************************************/
void initFeasibleNode()
{
	//printf("Done!\n");
	for(int i=0;i<consumNodeNum;i++)//标记每个消费节点能到达的节点
	{
		ifInTheTable[i][conNode[i].linkNode]=true;
		
		countNum=0;
		dfs(conNode[i].linkNode,conNode[i].demand,i);
	}

	for(int i=0;i<consumNodeNum;i++)//查找可能的公共节点
	{												//commonFlag中保存节点所能到达的消费节点数
		for(int j=0;j<nodeNum;j++)
		{
			if(ifInTheTable[i][j])	commonFlag[j]++;//累计消费点个数
		}
	}
	//***保证与消费节点相邻的节点 在 潜在服务器节点表*****
	for(int i=0;i<consumNodeNum;i++)	commonFlag[conNode[i].linkNode] +=2;

	//for(int i=0;i<nodeNum;i++)	printf("%d ",commonFlag[i]);
	//printf("\n");
	//for(int i=0;i<nodeNum;i++)	if(commonFlag[i]>1)printf("%d ",i);
	//printf("\n");
	//***************创建潜在服务器节点表*****************
	for(int i=0;i<consumNodeNum;i++)//记录每个消费节点的 潜在服务器节点
	{
		for(int j=0;j<nodeNum;j++)
		{
			if(ifInTheTable[i][j]&&(commonFlag[j]>1))
			{
				conNode[i].feasibleServiceNode[conNode[i].feasibleServiceNodeNum]=j;
				//printf("%d ",j);
				conNode[i].feasibleServiceNodeNum++;
			}
		}
		//printf("\n");
	}
	//for(int i=0;i<consumNodeNum;i++)	printf("feasibleServiceNodeNum:%d\n",conNode[i].feasibleServiceNodeNum);
}
/*********************************************************************
*****深度优先搜索函数:ifInTheTable中标记消费节点能到达的普通节点******
*********************************************************************/
void dfs(int topNode,int demand,int n)//深度优先搜索,ifInTheTable中标记
{
	if(countNum>=nodeNum)	return;
	for(int i=0;i<node[topNode].linkedNum;i++)
	{
		if(countNum>=nodeNum)	return;
		tmpCost+=node[topNode].cost[i]*demand;
		if(serverPrice>=tmpCost)
		{
			if(!ifClogged[node[topNode].linkedNode[i]])
			{
				countNum++;
				//printf("countNum:%d\n",countNum);
				ifInTheTable[n][node[topNode].linkedNode[i]]=true;

				ifClogged[node[topNode].linkedNode[i]]=true;
				dfs(node[topNode].linkedNode[i],demand,n);
				ifClogged[node[topNode].linkedNode[i]]=false;
			}
		}
		tmpCost-=node[topNode].cost[i]*demand;
	}
}
/*********************************************************************
**********初始化接口函数:完成数据读取,潜在服务器节点的初始化************
*********************************************************************/
void initial(char* graph[MAX_EDGE_NUM],int edge_num)
{
	//一些数组的初始化
	for(int i=0;i<nodeNum;i++)	{node[i].linkedNum=0;node[i].reachedConNodeNum=0;}
	for(int i=0;i<consumNodeNum;i++)	{conNode[i].feasibleServiceNodeNum=0;}

	for(int i=0;i<nodeNum;i++)	ifClogged[i]=false;
	for(int i=0;i<nodeNum;i++)	commonFlag[i]=0;
	for(int i=0;i<consumNodeNum;i++)
	{
		for(int j=0;j<nodeNum;j++)	ifInTheTable[i][j]=false;
	}

  for(int i=0;i<MAX_PATH_NUM;i++)//路径暂存数组的初始化
  {
    for(int j=0;j<nodeNum;j++)
      FeasiblePath[i][j]=-1;
  }	

	for(int i=0;i<nodeNum;i++)//初始化 可能的消费节点的 存储数组 
	{
		for(int j=0;j<consumNodeNum;j++)
		{
			node[i].reachedConNode[j]=0;
		}
	}
	//for(int i=0;i<nodeNum;i++)printf("reachedConNodeNum:%d\n",node[i].reachedConNodeNum);

	dataCatch(graph,edge_num);
	sortBaedOnCost();

	initFeasibleNode();
}

